class A:
    
    classA_Var = "I am the class A variable"

    def __init__(self) -> None:
        self.var1 = "I am the variable Var1 in Class A"
        self.classA_Var = "I am instance variable in class A"
        self.name = "Mahir patel"

class B(A):

    classA_Var = "I am the class B variable"

    #OVERRIDING THE WHOLE METHOD OF ABOVE CLASS
    def __init__(self) -> None:

        super().__init__() #THIS IS FOR CALLING THE INIT OF THE BASE CLASS THAN IT WILL OVERRIDE AFTER

        self.var1 = "I am the variable Var1 in Class B"
        self.classA_Var = "I am instance variable in class B"


objA = A()
objB = B()

#IN THIS CASE U CAN SEE THE CLASSa_vAR IS OVERRITE BY THE CONSTRUCTOR SO THIS IS VARIABLE OVERRIDING FIRST PROGRAM FIND THE INSTANCE VARIABLLE(INSTANCE VARIABLE IS THAT VARIABLE WHICH IS IN THE CONSTRUCTOR) AND PRINT IT AND IF NOT FOUND THAN PRINT THE CLASS LEVEL VARIABLE
print(objB.classA_Var)


#IN THIS CASE THE WHOLE METHOD IS OVERRIDING SO THE PROCESS IS ...IT IS FIRST CHECK IN THE CLASS B FROM WHICH IT WAS CALLED AND SEARCH FOR THE INSTANCE VARIABLE AND IF FOUND THE VARIABLE THAN IT WILL PRINT THAT OR SEARCH FOR THE CLASS VARIABLE AND WILL PRINT IT
print(objB.classA_Var)


#BUT IF I WANT TO PRINT THE VARIABLE WHICH IS IN THE BASE CLASS AND BEFORE OVERRIDING SO FOR THAT WE HAVE TO USE THE SUPER() FUNCTION TO CALL THE CONSTRUCTIOR/INIT OF THE BASE CLASS FIRST AND THAN OVERIRIDE THE METHOD 
print(objB.name)  #WE GOT THE ERROR HERE BECAUSE THE METHOD IS OVERRIDING IN THESE CASE AND IF YOU WANT TO PRINT USE THE SUPER FUNCTION() BEFORE OVERRIDING THE METHOD

